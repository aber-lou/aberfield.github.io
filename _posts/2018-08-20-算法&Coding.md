---
layout: mypost
title: 算法& Coding
---

+  一直都有想法要把算法的东西重新捡起来，去年刷了一段时间LeetCode，看了一段时间牛客算法，但是度是半途而废，很难做到持之以恒。所以现在尽可能把算法一块的东西用Blog记录下来，也正好督促自己。

### LeetCode刷题

1. 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数，你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用，示例:

        ```
            给定 nums = [2, 7, 11, 15], target = 9

            因为 nums[0] + nums[1] = 2 + 7 = 9
            所以返回 [0, 1]
        ```

+ 这题最暴力解法是直接循环遍历找出对应的那一组解，然后丢出来，但是时间复杂度在O(n^2),所以不太适合。
        
+ 我们可以将考虑将nums数组转化为HashMap，以Value作Key，Index为值，不考虑hash碰撞的情况下，Hash找对对应元素的时间复杂都为O(1)，所以整个解法的时间复杂度应该是O(n)，[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。


2. 给定两个非空链表来表示两个非负整数。位数按照逆序的方式来存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字0之外，数字不会以0开头，示例:

        ```
        输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
        输出：7 -> 0 -> 8
        原因：342 + 465 = 807
        ```

+ 这题主要是考察链表使用的熟练度，遍历链表直到Next节点都为空，这里需要的将两个链表当前节点值相加，根据是否需要进位记录状态。用Swift的实现[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。

    
3. 无重复字符串的最长子串，示例:
   
        ```
         输入: "abcabcbb"
         输出: 3 
         解释: 无重复字符的最长子串是 "abc"，其长度为 3。

         输入: "bbbbb"
         输出: 1
         解释: 无重复字符的最长子串是 "b"，其长度为 1。

         输入: "pwwkew"
         输出: 3
         解释: 无重复字符的最长子串是 "wke"，其长度为 3。
             请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。
        ```

+ 比较暴力的解法就是两次遍历，然后找出最长的子串，返回。我的想法是准备一个SubString，对String进行遍历，然后判断String是否包含String的Character，如果不包含，添加到SubString，如果包含，移除SubString首个Character直到SubString不再包含String的Character，代码是基于Swift4.0的，在4.0之前Swift String不能支持Collection，所以会额外准备一个Set来装子串。[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。

4. 两个排序数组中的中位数，给定给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) ，你可以假设 nums1 和 nums2 不同时为空,示例：
    
        ```
            nums1 = [1, 2]
            nums2 = [3, 4]

            中位数是 (2 + 3)/2 = 2.5
        ```

+ 不管什么算法题，我一开始都会想着用暴力办法去实现一遍，所以这个一开始的想法是把两个数组合并在一块，同时对其进行排序，然后找出中位数。后面想一下，其实可以考虑用递归的办法去实现，依次找出两个有序数组中中位数。[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。


5. 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。这个算法有点没太懂。有空再研究，下面是摘录。[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。
    
 + 这个解法是 O(n^2) 的。DP，先搜长度为 1、为 2…… 至 n。之所以写法很不简洁，多出了许多临时变量，完全是 swift 的锅。谨记 swift 字符串的特性，由于每一位字符长度不一定相等，它是不能随机访问的。也就是说，如果不存临时变量，取某一位的字符、取字符串的长度、截取子串，全部都是 n 级别的…… 所以一再超时。
 + 最坑的是，我之前写作 isPalidromeMatrix[startIndex][endIndex] = ... 这样就会超时，而
 + if (...) {isPalidromeMatrix[startIndex][endIndex] = true} 这样就不会。只不过多赋值了一些 false……
 + 而且把 if isPalidrome 改成 if isPalidromeMatrix[startIndex][endIndex] ，时间会长一倍。感觉数据量稍微一大，swift 性能问题真的挺严重。
 + 时间复杂度：O(n^2) 空间复杂度：O(n^2)


1.  给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。如图
  
![图片](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/question_11.jpg)

+ 第一件事就想着暴力法，直接两次遍历，找出最大的面积即可。时间复杂度O(n^2)，空间复杂度O(1)。还有一种比较好点的办法是双向指针，头尾指针向中间扫，依次找出最大面积来，时间复杂度O(n)，空间复杂度O(1)。[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。


12. 小灰程序员微信公众号上面的题目。给定一个整数，从整数当中去掉k个数字，要求剩下的数字形成的新整数尽可能的小，应用如何选取去掉的数字。比如给定整数string ‘1593212’，那么删除3个数字之后，最小值应该是‘1212’。

+ 思路：按照题意，题解应该是从高位到低位，去除string中比相邻高位大的数字，如果不够K位，则去除末尾数字。

+ 这里的解法是用过定义一个栈做处理，依次将高位数字入栈操作，入栈前判断元素是否小于栈顶元素，如果小于则出栈，继续对比当前栈顶元素，依次操作。时间负责度O(kn)，[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。


12. LeetCode上第12题，例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
    - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
    - 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
 
+ 解法：可以一次推算出每一个数值对应的罗马字符串，然后进行拆分对应，输出即可。有更好的办法可以，采用递归办法，先取出高位罗马字符串，依次递归。[题解](https://github.com/aberfield/WorkSpace/tree/master/LeetCodeProject/LeetCodeProject)。