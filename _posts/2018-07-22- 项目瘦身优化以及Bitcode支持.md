---
layout: mypost
title: 关于公司项目Bitcode实践，以及IPA包瘦身
---

### 这两天准备给手头上的项目做一下优化，第一部分是安装包体积缩减。

+ 发现项目至今还不支持Bitcode，第一步先做一下Bitcode支持。

### Bitcode优化

+ 什么是Bitcode
  1. Bitcode是Xcode编译打包的一种中间码，在包含Bitcode配置的程序被上传到App Store之后，App Store也可以对其进行编译和链接。同时，Bitcode允许苹果后期重新优化程序的二进制执行文件。苹果会根据下载应用的用户手机指令集类型生成该指令集的二进制文件，进行下发下载 ,如下:

  ![Bitcode.png](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/bitcode.png)

  2. 在打包之后开启了Bitcode的包体积会被未开启的稍大一丢丢，提交到到App Store之后，App Store会根据下载设备进行优化，分发下载。

+ Bitcode是iOS9.0.2才正式支持的，iOS9.0.2以下的的系统还是下的全量架构的包，所以包会比之前未开启Bitcode的包还要大点。

+ App Thinning
    1. Slicing，把App安装包上次到App Store后，Apple分析处理服务会自动对安装包切割为不同的应用变体，用户下载安装包时，系统会根据设备型号下载对应的应用变体。
    2. On-Demand Resources 随需资源开发对资源加标签上传后，系统会根据App运行情况，动态下载并加载所需资源，而在存在存储空间不足时，自动删除这类资源。
    3. Bitcode，开启bitcode编译后，可以使得开发者上次App时只需上传Intermediate Representation（中间文件），而非最终的可执行二进制文件。用户下载之前，App Store会自动编译中间件，产生设备所需的执行文件。

+ 开启Bitcode的好处是可以支持动态的App Slicing，对于Apple未来进行的硬件升级措施，此机制可以保证开发者不在重新发版的情况下兼容新的设备。

+ 开启Bitcode之后，用户在App Store下载的包体积可以小很多。

+ 需要注意点地方： 
  1. 开启Bitcode之后，那么集成的其他第三方库也需要支持Bitcode。
  2. 开启Bitcode之后，打包生产的.dsym文件不能用来当做崩溃日志的符号文件，因为用户下载的事App Store重新编译生成的符号文件。
  3. 关于符号文件，我们可以在Xcode的Organizers下载对应的符号文件

### 增加BitCode支持

+ 更改项目 ```Targets-> Build Setting -> Enable Bitcode``` 为 YES

+ 让所有Pod库增加Bitcode支持，在Podfile文件```post_install do |installer|```增加Bitcode参数设定，关于post_install内容的资料可以查阅[这里](https://cocoapods.org/)如下:

```
post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['ENABLE_BITCODE'] = 'YES'
        end
    end
end
```

+ 开启之后重新打包，内测版本包大小缩减了10M左右，但是其中删除了一个8M的无用静态库。总体来说还是有所改善。


### 资源文件瘦身

+ 资源文件包括图片，声音，视频，文本文件等。
  1. 通过LSUnusedResources工具对项目进行检索，找出没有用到的图片资源，删除无用图片资源

  2. 检测项目中过大图片，可以使用[TinyPng](https://tinypng.com/)等压缩工具对图片进行压缩。

    + 正常图片大小: 
    > ![图片](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/normal.png)


    + 压缩之后图片大小:
    > ![图片](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/compress.png)

  3. 考虑将部分资源迁移到线上，不打包到安装包中。

+ 删除无用的代码和xib文件其实也算一部分的优化内容，不过没有找到好的检测工具，后续有时间利用SourceKitten做个小工具玩玩。

+ 项目中使用了大量的Storyboard、xib，其实可以考虑后期需求撸纯代码，看了一下 一个xib文件大概10多K，整个项目下来几百个xib文件，几十个storyboard文件，这一部分如果优化可以让安装包体积少几MB。

+ 项目经过这两年的迭代，功能的新增修改删除，避免不了遗留了很多无用代码，或者是无用逻辑，所以删除无用代码文件，无用逻辑代码自然而然也是减少包体积的方法之一，没有找到合适的脚本工具，所以还未对项目进行这方面的优化，下面记录两篇文章:
  1. [SourceKitten](https://github.com/jpsim/SourceKitten), Swift项目源码处理工具,自动补全，查找遍历语法树，SwiftLint，SwiftMocky等都是基于此实现的，功能很强大，待发掘。
  2. [如何使用Clang Plugin找到项目中的无用代码](https://blog.gocy.tech/2017/09/12/DetectingUselessCodeWithClang-p1/),这系列的文章可以看看，挺有用的。
  3. [App无用代码/重复代码分析](http://kangwang1988.github.io/tech/2016/11/01/find-unused-duplicate-code-of-your-app-using-clang-plugin.html)

### 总结

+ 整体来说项目这里只是一个简单的瘦身，优化。其实应该还是有更多的优化空间的，整体项目在蒲公英上内测包大小大概从35MB剪少到了19.5MB,App Store下载的安装包大小也从50MB减少到了37MB的样子。今后有时间再钻研钻研。

+ 后续更新。。。


### 参考文章
> [Bitcode适配指南](http://www.cocoachina.com/ios/20151201/14432.html)

+ 关于里面的编译原理这里做一下摘录

1. Lexer :读入源文件，并将其转化成字符流

2. Parser :将字符流转换成AST（抽象语法树）

3. Semantic Analysis: 对输入的AST进行语法检查。

4. Code Generation: 代码生成，将AST转换成低层次的IR指令

5. Optimization: 分析IR指令，将其中潜在会拖慢运行速度的指令干掉。

6. AsmPrinter: 通过IR（中间码）生成特定CPU架构的汇编代码

7. Assemble: 将汇编代码转化成二进制

8. Linker: 通常程序会引用其他的二进制文件（.a或者framework)，但是这些链接在程序中没有正确的地址，只是个占位符。Linker的工作就是给这些占位符正确的地址。

+ 更多编译原理内容[The Compiler](https://www.objc.io/issues/6-build-tools/compiler/)