---
layout: mypost
title: iOS开发中遇到的问题以及解决方案
---

### 如何修改TableView编辑模式下的选中拖动按钮

+ TableView编辑模式下的选中拖动按钮是默认的，而且TableView并没有开发相关属性供我们修改。但是设计师强烈要求我改掉这两个图标，也算是挺无奈的。
  
    - ![系统默认图标](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/move.png)

    - ![修改之后图标](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/modify.png)

+ 开发思路：
  
    1. 通过查看应用视图层级定位到对应的View，找到对应所属的属性和类名描述。

        - ![对应视图类名](https://raw.githubusercontent.com/aberfield/aberfield.github.io/master/posts/className.png)

    2. 在Cell的```setEditing```方法通过遍历Content视图找到对应的子视图类，根据对应的类名获取对象，并且通过KVC获取对象中的ImageView属性，因为SetEditing调用算是比较高频的方法，所以我们在设置完一次ImageView属性之后可以考虑记录状态，防止下次继续遍历设置视图产生多余的性能消耗，代码如下:
    

        ```
        /// Cell移动子类
        private let reorderControlClassName = "UITableViewCellReorderControl"
    
        /// Cell选中子类
        private let editControlClassName = "UITableViewCellEditControl"
        
        /// 是否有设置过移动图标
        private var setReorderImage: Bool = false
    
        /// 是否有设置过编辑图标
        private var setEditImage: Bool = false

        .
        .
        .
        override func setEditing(_ editing: Bool, animated: Bool) {
            super.setEditing(editing, animated: animated)

            /// 当两个值都有执行过得情况下，不进行遍历设置
            if editing && !(setReorderImage && setEditImage) {
                for view in self.subviews {
                    if NSStringFromClass(view.classForCoder) == reorderControlClassName, !setReorderImage {
                        if let imageView = view.value(forKeyPath: "imageView") as? UIImageView {
                            imageView.image = #imageLiteral(resourceName: "follow_group_sort")
                            let orgin = imageView.frame.origin
                            imageView.frame = CGRect.init(x: 14, y: orgin.y, width: 18, height: 18)
                            setReorderImage = true
                            continue
                        }
                    }
                
                    if NSStringFromClass(view.classForCoder) == editControlClassName, !setEditImage {
                        guard let imageView = view.value(forKeyPath: "imageView") as? UIImageView, let control = view as? UIControl else { continue }
                        selectControl = control
                        selectionImageView = imageView
                        setEditImage = true
                    }

                }
            }

        }

        ```

    
    3. 通过以上设置设置完移动和选中的ImageView页面展示和我们预期差不多，但是当你选中一个Cell的情况下，选中图标又会变更为系统自带图标了，所以需要在Cell进行```LayoutSubviews```的时候对视图图片进行重新设置,因为在SetEditing中我记录下了选中视图的对象，所以可以通过属性的ImageView进行重新设置就好，代码如下:

        ```
        override func layoutSubviews() {
            super.layoutSubviews()

            // 无选中模式直接返回
            guard leftMarginConstrain.constant == leftMargin else {
                return
            }
        
            if setEditImage {
                selectionImageView?.image = selectControl!.isSelected ? #imageLiteral(resourceName: "followedEdit_selected") : #imageLiteral(resourceName: "followedEdit_unselect")
            }else {
                // 这里涉及到遍历，相比较来说这里的效率会比较低
                for view in self.subviews {
                    if NSStringFromClass(view.classForCoder) == editControlClassName {
                        guard let imageView = view.value(forKeyPath: "imageView") as? UIImageView, let control = view as? UIControl else { break }
                        selectControl = control
                        selectionImageView = imageView
                        imageView.image = control.isSelected ? #imageLiteral(resourceName:  "followedEdit_selected") : #imageLiteral(resourceName: "followedEdit_unselect")
                        break
                    }
                }
            }
        }

        ```

    4. 基本上通过以上两个方法就能进行Cell选中和移动图标的更改，像LayoutSubviews调用频次非常高的方法我们考虑更多的就是需要如何避免不必要的赋值了。