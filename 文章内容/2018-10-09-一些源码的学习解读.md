---
layout: mypost
title: 一些知名框架的解读学习
---

### BSBacktraceLogger -- 一个轻量级iOS调用栈分析器

+ 这是一个强大且轻量的线程调用栈分析器，只有一个类，四百行代码。它支持现有所有模拟器、真机的 CPU 架构，可以获取任意线程的调用栈，因此可以在检测到 runloop 检测到卡顿时获取卡顿处的代码执行情况。

+ 将 NSThread 转换成 thread_t，这里主要是设置NSThread 的名称然后通过获取 thread_t 名称对比找到相对应的线程，有在issue看到说如果再其他线程设置别的线程名称，thread_t 所对应的线程名称是无法设置上,会导致无法获取到所需线程的堆栈。

    ```
        // 获取线程list 以及数量
        task_threads(mach_task_self(), &list, &count);

        NSTimeInterval currentTimestamp = [[NSDate date] timeIntervalSince1970];
        NSString *originName = [nsthread name];

        // 给线程设置名称，然后通过thread_t 获取线程名称，对比之后返回thread_t
        [nsthread setName:[NSString stringWithFormat:@"%f", currentTimestamp]];


        if ([nsthread isMainThread]) {
            return (thread_t)main_thread_id;
        }

        printf("%u\n", main_thread_id);

        for (int i = 0; i < count; ++i) {
            pthread_t pt = pthread_from_mach_thread_np(list[i]);
            printf("%u\n", list[i]);
            // 这里应该不用再判断是否为主线程了
            if ([nsthread isMainThread]) {
                if (list[i] == main_thread_id) {
                    return list[i];
                }
            }
            if (pt) {
                name[0] = '\0';
                pthread_getname_np(pt, name, sizeof name);
                printf("%s\n",name);
                if (!strcmp(name, [nsthread name].UTF8String)) {
                    [nsthread setName:originName];
                    return list[i];
                }
            }
        }

    ```

+ 这个框架还需在研究研究，里面关于获取线程信息，地址，偏移量的东西看的似懂非懂。 

+ 项目地址  [BSBacktraceLogger](https://github.com/bestswifter/BSBacktraceLogger)