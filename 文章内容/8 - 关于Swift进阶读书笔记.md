---
layout: mypost
title:  Swift进阶读书笔记.
---

### Swift编程风格

- 对于命名，在使用时能清晰表意是最重要。因为 API 被使用的次数要远远多于被声明的次数，所以我们应当从使用者的角度来考虑它们的名字。尽快熟悉 Swift API 设计准则，并且在你自己的代码中坚持使用这些准则。
<br />
- 简洁经常有助于代码清晰，但是简洁本身不应该独自成为我们编码的目标。
<br />
- 务必为函数添加文档注释 — 特别是泛型函数。
<br />
- 类型使用大写字母开头，函数、变量和枚举成员使用小写字母开头，两者都使用驼峰式命名法。
<br />
- 使用类型推断。省略掉显而易见的类型会有助于提高可读性。
<br />
- 如果存在歧义或者在进行定义的时候不要使用类型推断。(比如 func 就需要显式地指定返回类型)
<br />
- 优先选择结构体，只在确实需要使用到类特有的特性或者是引用语义时才使用类。
<br />
- 除非你的设计就是希望某个类被继承使用，否则都应该将它们标记为 final。
<br />
- 除非一个闭包后面立即跟随有左括号，否则都应该使用尾随闭包 (trailing closure) 的语法。
<br />
- 使用 guard 来提早退出方法。
<br />
- 避免对可选值进行强制解包和隐式强制解包。它们偶尔有用，但是经常需要使用它们的话往往意味着有其他不妥的地方。
<br />
- 不要写重复的代码。如果你发现你写了好几次类似的代码片段的话，试着将它们提取到一个函数里，并且考虑将这个函数转化为协议扩展的可能性。
- 试着去使用 map 和 reduce，但这不是强制的。当合适的时候，使用 for 循环也无可厚非。高阶函数的意义是让代码可读性更高。但是如果使用 reduce 的场景难以理解的话，强行使用往往事与愿违，这种时候简单的 for 循环可能会更清晰。
<br />
- 试着去使用不可变值：除非你需要改变某个值，否则都应该使用 let 来声明变量。不过如果能让代码更加清晰高效的话，也可以选择使用可变的版本。用函数将可变的部分封装起来，可以把它带来的副作用进行隔离。
<br />
- Swift 的泛型可能会导致非常长的函数签名。坏消息是我们现在除了将函数声明强制写成几行以外，对此并没有什么好办法。我们会在示例代码中在这点上保持一贯性，这样你能看到我们是如何处理这个问题的。
<br />
- 除非你确实需要，否则不要使用 self.。在闭包表达式中，使用 self 是一个清晰的信号，表明闭包将会捕获 self。
<br />
- 尽可能地对现有的类型和协议进行扩展，而不是写一些全局函数。这有助于提高可读性，让别人更容易发现你的代码。

### 泛型的工作方式

- Swift通过泛型代码引入一层间接的中间层来解决这些问题。当编译器遇到一个泛型类型的值时，它会将其包装到一个容器中。这个容器有固定的大小，并存储这个泛型值。如果这个值超过容器的尺寸，Swift 将在堆上申请内存，并将指向堆上该值的引用存储到容器中去。
<br />
- 对于每个泛型类型的参数，编译器还维护了一系列一个或者多个所谓的目击表 (witness table)：其中包含一个值目击表，以及类型上每个协议约束一个的协议目击表。这些目击表 (也被叫做 vtable) 将被用来将运行时的函数调用动态派发到正确的实现去。
<br />
- `对于任意的泛型类型，总会存在值目击表，它包含了指向内存申请，复制和释放这些类型的基本操作的指针`。这些操作对于像是 Int 这样的值类型来说，可能不需要额外操作，或者只是简单的内存复制，不过对于引用类型来说，这里也会包含引用计数的逻辑。值目击表同时还记录了类型的大小和对齐方式。
<br />
- Swift泛型设计的模式为`编译一次，动态派发`，但是这么做的缺点很明显，就是在运行时性能会被严重拉低。对于单个函数调用这个开销可以忽略，但是因为泛型在Swift中非常的普及，所以它的这种性能开销很容易堆叠起来。标准库中到处是泛型，包括比较值得大小在内很多常用操作必须做到快速，而且这里操作也十分频繁，所以这种影响可以说比较大。
<br />
- 不过Swift采取了泛型特化来避免这种额外开销。`泛型特化`是指，编译器按照具体的参数参数类型 (比如 Int)，将 `min<T>` 这样的泛型类型或者函数进行复制。特化后的函数可以将针对 Int 进行优化，移除所有的额外开销。
<br />
- 泛型特化只能在编译器可以看到泛型类型的全部定义以及想要进行特化的类型的时候才能生效。但是 Swift 编译器默认情况下是对源文件进行单独编译的，所以只有在使用泛型的代码和定义泛型代码在同一个文件中时，泛型特化才能工作。因为这是一个很严重的限制，所以编译器引入了一个标志来启用全模块优化。在这个模式种，当前模块的所有文件会被当作全部都在一个文件中来进行优化，这让泛型特化可以横跨整个代码库进行工作。你可以通过向 swiftc 传递 -whole-module-optimization 来开启全模块优化。请确保在发布版本 (甚至可能的话在调试版本) 中进行这项操作，因为这将大幅提升性能。不过缺点是会带来更长的编译时间。

### 协议

- 通过协议进行代码共享相比于继承的优势：
  1. 我们不需要被强制使用某个父类。
  2. 我们可以让已经存在的类型满足协议 (比如我们让 CGContext 满足了 Drawing)。子类就没那么灵活了，我们无法以追溯的方式去变更 CGContext 的父类。
  3. 协议既可以用于类，也可以用于结构体，而父类就无法和结构体一起使用了。
  4. 当处理协议时，我们无需担心方法重写或者在正确的时间调用 super 这样的问题。
<br />
- Swift协议可以分为两种类型，带有关联类型的协议和普通类型的协议。
<br />
- 通过协议类型创建一个变量的时候，这个变量会被包装到一个叫做存在容器的盒子，可以稍微剖析一下这个容器盒子的内容

```
func f<C: CustomStringConvertible>(_ x: C) -> Int {
    return MemoryLayout.size(ofValue: x)
}
func g(_ x: CustomStringConvertible) -> Int {
    return MemoryLayout.size(ofValue: x)
}
f(5) // 8
g(5) // 40
```

8 字节和 40 字节的尺寸差别是怎么来的？因为 f 接受的是泛型参数，整数 5 会被直接传递给这个函数，而不需要经过任何包装。所以它的大小是 8 字节，也就是 64 位系统中 Int 的大小。对于 g，整数会被封装到一个存在容器中。对于普通的协议，会使用不透明存在容器 (opaque existential container)。不透明存在容器中含有一个存储值的缓冲区 (大小为三个指针，也就是 24 字节)；一些元数据 (一个指针，8 字节)；以及若干个目击表 (0 个或者多个指针，每个 8 字节)。如果值无法放在缓冲区里，那么它将被存储到堆上，缓冲区里将变为存储引用，它将指向值在堆上的地址。元数据里包含关于类型的信息 (比如是否能够按条件进行类型转换等)


- 关于协议和泛型的性能影响:
存在容器为代码调用添加了一层非直接层，所以相对于泛型参数，一般来说都会造成性能降低。除了可能更慢的方法派发以外，存在容器还扮演了阻止编译器优化的壁垒角色。大多数时候，担忧这里的性能其实是过早优化。但是，如果你想要获取最大化的性能的时候，使用泛型参数确实要比使用协议类型高效得多。通过使用泛型参数，你可以避免隐式的泛型封装。
<br />
如果你尝试将一个 [String] (或者其他任何类型) 传递给一个接受 [Any] (或者其他任意接受协议类型，而非具体类型的数组) 的函数时，编译器将会插入代码对数组进行映射，将每个值都包装起来。这将使方法调用本身成为一个 O(n) 的操作 (其中 n 是数组中的元素个数)，这还不包含函数体的复杂度。同样的，大多数情况下这不会导致问题，但是如果你需要写高性能的代码，你可能需要将你的函数写为泛型参数的形式，而不是使用协议类型：

```
// 隐式打包
func printProtocol(array: [CustomStringConvertible]) {
    print(array)
}
// 没有打包
func printGeneric<A: CustomStringConvertible>(array: [A]) {
    print(array)
}
```

### Swift这本书做的笔记比较少，之后有时间还会再温故下。
